<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Torrente online bots</title>
    <link rel="stylesheet" href="styles.css">
    <style>body { margin:0 }</style>
</head>
<body>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
const BOT_STATES = {
    ATTACK: 'attack',
    NO_ATTACK: 'no_attack'
};
let camera, scene, renderer, controls;
let mapMeshes = [];
let botMeshes = [];
let players = {};
let state_bots = {
}
let forwardLines = {};
let botRaycasters = {};
let botPrototype;
const wireMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });


const wireMaterialBot = new THREE.MeshBasicMaterial({ color: 0x00c8ff, wireframe: true });

const move = { forward: false, backward: false, left: false, right: false };
const playerSpeed = 0.25;

const SENSOR_HEIGHT  = 80;
const FORWARD_OFFSET = 30;
const SENSOR_LENGTH  = 400 * 3;

const COLOR_FREE = new THREE.Color(0xff8800);
const COLOR_WALL = new THREE.Color(0xff0000);
const COLOR_BOT  = new THREE.Color(0x0000ff);

init();

async function init() {

    camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 100000);
    camera.position.set(0, 120, 250);

    scene = new THREE.Scene();

    scene.add(new THREE.AmbientLight(0xffffff, 1.2));

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(devicePixelRatio);
    document.getElementById('ocultar').appendChild(renderer.domElement);

    // ORBIT CONTROLS
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.enablePan = true;
    controls.enableZoom = true;
    controls.maxPolarAngle = Math.PI * 0.49;

    window.addEventListener('resize', onResize);

    const loader = new OBJLoader().setPath('./');
    const gloader = new GLTFLoader();

    // MAPA
    try {
        const mapObj = await loader.loadAsync('map.obj');
        mapObj.position.y = -1;

        mapObj.traverse(c => {
            if (c.isMesh) {
                c.material = wireMaterial;
                c.material.side = THREE.DoubleSide;
                c.userData.type = 'wall';
                mapMeshes.push(c);
            }
        });
        scene.add(mapObj);
    } catch(e) { console.warn("map.glb no cargado", e); }

    // BOT PROTOTYPE
    try {
        botPrototype = await loader.loadAsync('model.bot.obj');
        botPrototype.scale.setScalar(100);
        botPrototype.traverse(c => {
            if (c.isMesh) {
                c.material = wireMaterialBot;
                c.userData.type = 'bot';
            }
        });
    } catch(e) { console.warn("model.bot.obj no cargado", e); }

    // BOT LOCAL
    if (botPrototype) {
        const bot0 = botPrototype.clone();
        bot0.position.set(0, 0, 0);
        scene.add(bot0);
        players[0] = bot0;
        botMeshes.push(bot0);
        //createBotSensor(0);
    }

    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);

    connectSSE();
    animate();
}

function onKeyDown(e){
    if (e.code === 'KeyW') move.forward = true;
    if (e.code === 'KeyS') move.backward = true;
    if (e.code === 'KeyA') move.left = true;
    if (e.code === 'KeyD') move.right = true;
}

function onKeyUp(e){
    if (e.code === 'KeyW') move.forward = false;
    if (e.code === 'KeyS') move.backward = false;
    if (e.code === 'KeyA') move.left = false;
    if (e.code === 'KeyD') move.right = false;
}

function createBotSensor(id) {
    botRaycasters[id] = new THREE.Raycaster();

    const line = new THREE.Line(
        new THREE.BufferGeometry(),
        new THREE.LineBasicMaterial({ color: 0xffffff })
    );
    scene.add(line);
    forwardLines[id] = line;
}

function updatePlayerMovement() {
    const bot = players[0];
    if (!bot) return;

    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    dir.y = 0;
    dir.normalize();

    const right = new THREE.Vector3().crossVectors(dir, camera.up).normalize();

    if (move.forward)  bot.position.addScaledVector(dir, playerSpeed);
    if (move.backward) bot.position.addScaledVector(dir, -playerSpeed);
    if (move.left)     bot.position.addScaledVector(right, -playerSpeed);
    if (move.right)    bot.position.addScaledVector(right, playerSpeed);

    controls.target.copy(bot.position);
}

function updateAllSensors() {
    for (const id in players) {
        if(id == 0){
            updatePlayerMovement();
            continue;
        }else{
            const bot = players[id];
            const ray = botRaycasters[id];
            const line = forwardLines[id];

            const origin = bot.position.clone();
            origin.y += SENSOR_HEIGHT;

            const forward = new THREE.Vector3();
            bot.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize().multiplyScalar(-1);

            const start = origin.clone().addScaledVector(forward, FORWARD_OFFSET);
            const end = start.clone().addScaledVector(forward, SENSOR_LENGTH);

            line.geometry.setFromPoints([start, end]);

            ray.set(start, forward);
            const hits = ray.intersectObjects([...mapMeshes, ...botMeshes.filter(b => b !== bot)], true);

            let color = COLOR_FREE.clone();
            if (hits.length > 0) {
                const t = hits[0].object.userData?.type;
                if (t === 'wall'){
                    color = COLOR_WALL.clone();
                    //console.log('bot pierde vision')
                    
                    process_state(id, BOT_STATES.NO_ATTACK)
                }
                if (t === 'bot'){
                    process_state(id, BOT_STATES.ATTACK)
                    //console.log('bot pide disparar a jugador')
                    color = COLOR_BOT.clone();
                }
            }
            line.material.color.copy(color);
        }
    }
}
const SENSOR_DT = 1; // 100 ms = 10 Hz
let acc = 0;
const clock = new THREE.Clock();
function animate() {
    requestAnimationFrame(animate);

    acc += clock.getDelta();

    if(acc >= SENSOR_DT){
        updateAllSensors();
        acc = 0;
    }
    controls.update();

    renderer.render(scene, camera);
}

function onResize() {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
}

// SSE
function connectSSE() {
    const source = new EventSource('/api/connect');
    source.onmessage = e => {
        try {
            processAction(JSON.parse(e.data));
        } catch(err) {
            console.error(new Error(err))
        }
    };
}

function processAction(action) {
    if (action.type_action === 'spawn' && botPrototype && action.id_bot !== 0) {
        const bot = botPrototype.clone();
        bot.position.set(action.value_action.x, action.value_action.z, -action.value_action.y);
        scene.add(bot);
        players[action.id_bot] = bot;
        process_state(action.id_bot, BOT_STATES.NO_ATTACK)
        botMeshes.push(bot);
        createBotSensor(action.id_bot);
    }

    if (action.type_action === 'sync') {
        const bot = players[action.id_bot];
        if (!bot) return;

        bot.position.set(action.value_action.x, action.value_action.z, -action.value_action.y);

        if (typeof action.value_action.r === 'number') {
            bot.rotation.y = -(action.value_action.r / 256) * Math.PI * 2;
        }
        //percebir()
        //decidir
        //actuar
        
    }
    
    if (action.type_action === 'die' && action.id_bot !== 0) {
        
        const id = action.id_bot;
        console.log('boy die: ', id)
        const bot = players[id];

        if (!bot) return;

        scene.remove(bot);

        const i = botMeshes.indexOf(bot);
        if (i !== -1) botMeshes.splice(i, 1);

        if (forwardLines[id]) {
            scene.remove(forwardLines[id]);
            forwardLines[id].geometry.dispose();
            forwardLines[id].material.dispose();
            delete forwardLines[id];
        }

        delete botRaycasters[id];

        delete players[id];

    }
}

async function process_state(id_bot, state){
    const last_state = state_bots[id_bot]
    state_bots[id_bot] = state
    
    switch(state_bots[id_bot]){
        case BOT_STATES.ATTACK:
            if(last_state !== BOT_STATES.ATTACK){
                console.log('attack')
                await send_action(id_bot, BOT_STATES.ATTACK)
            }
        break;
        case BOT_STATES.NO_ATTACK:
            console.log('no attack')
        break;
        default: 
        break;
    }

}
async function send_action(id_bot, action){
        const response_connection = await fetch('/api/action_bot',{
        method: 'POST',
        headers: {
            "Content-Type": "application/json"
        },
        body: JSON.stringify({
            id_bot: id_bot,
            state_bot: action 
        }),

    })
}
</script>

<div class="welcome"><span>torrenteservidor.es</span></div>


<div class="formulario">
    <div class="tituloformulario"><span>CONECTAR BOTS</span></div>
    <div class="datosformulario">
        <label>Dirección IP:<br><input type="text" id="ipv4" value="192.168.1.130"></label>
        <label>Puerto:<br><input type="number" id="puerto" value="8888"></label>
        <label>Número de bots:<br><input type="number" id="numbots" max="32" value="15"></label>
        <input id="boton" type="button" value="Conectar" onclick="btnocultar()">
    </div>
    <div class="btnocultar"><button>Mostrar / Ocultar</button></div>
</div>

<script src="index.js"></script>

<div id="ocultar" style="display: none;"></div>
</body>
</html>
