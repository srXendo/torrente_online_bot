<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Torrente online bots</title>
    <link rel="stylesheet" href="styles.css">
    <style>body { margin:0 }</style>
</head>
<body>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

let camera, scene, renderer, controls;
let mapMeshes = [];
let botMeshes = [];
let players = {};
let state_bots = {
}
const move_actions = {camera_right: {action_type: "camera_right"}, camera_left: {action_type: "camera_left"}, forward: {action_type: "forward_move"}, backward: {action_type: "backward_move"}, left: {action_type: "left_move"}, right: {action_type: "right_move"}}
const BOT_STATES = {
    NO_ATTACK: 'no_attack',
    PATROL: 'patrol',
    CHASE: 'chase',
    ATTACK: 'attack'
};

const PATROL_CONFIG = {
    WAYPOINT_RADIUS: 5,
    WAIT_TIME: 2000,
    PATROL_SPEED: 0.5,
    EXPLORATION_RANGE: 20
};
const botPatrolData = {};
function initPatrol(botId, centerX, centerZ, numWaypoints = 4) {
    botPatrolData[botId] = {
        state: BOT_STATES.PATROL,
        waypoints: [],
        currentWaypointIndex: 0,
        lastWaypointTime: Date.now(),
        waiting: false,
        patrolCenter: { x: centerX, z: centerZ },
        patrolRadius: PATROL_CONFIG.EXPLORATION_RANGE
    };
    
    for (let i = 0; i < numWaypoints; i++) {
        const angle = (i / numWaypoints) * Math.PI * 2;
        const x = centerX + Math.cos(angle) * PATROL_CONFIG.EXPLORATION_RANGE;
        const z = centerZ + Math.sin(angle) * PATROL_CONFIG.EXPLORATION_RANGE;
        botPatrolData[botId].waypoints.push({ x, z });
    }
}

function setPatrolMode(botId, centerX, centerZ) {
    initPatrol(botId, centerX, centerZ);
    if (players[botId]) {
        process_state(botId, BOT_STATES.PATROL);
    }
}

function addWaypoint(botId, x, z) {
    if (botPatrolData[botId]) {
        botPatrolData[botId].waypoints.push({ x, z });
    }
}
let forwardLines = {};
let botRaycasters = {};
let botPrototype;
const wireMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });


const wireMaterialBot = new THREE.MeshBasicMaterial({ color: 0x00c8ff, wireframe: true });

const move = { forward: false, backward: false, left: false, right: false };
const playerSpeed = 0.25;

const SENSOR_HEIGHT  = 80;
const FORWARD_OFFSET = 30;
const SENSOR_LENGTH  = 400 * 3;

const COLOR_FREE = new THREE.Color(0xff8800);
const COLOR_WALL = new THREE.Color(0xff0000);
const COLOR_BOT  = new THREE.Color(0x0000ff);

init();

async function init() {

    camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 100000);
    camera.position.set(0, 120, 250);

    scene = new THREE.Scene();

    scene.add(new THREE.AmbientLight(0xffffff, 1.2));

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(devicePixelRatio);
    document.getElementById('ocultar').appendChild(renderer.domElement);

    // ORBIT CONTROLS
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.enablePan = true;
    controls.enableZoom = true;
    controls.maxPolarAngle = Math.PI * 0.49;

    window.addEventListener('resize', onResize);

    const loader = new OBJLoader().setPath('./');
    const gloader = new GLTFLoader();

    // MAPA
    try {
        const mapObj = await loader.loadAsync('map.obj');
        mapObj.position.y = -1;

        mapObj.traverse(c => {
            if (c.isMesh) {
                c.material = wireMaterial;
                c.material.side = THREE.DoubleSide;
                c.userData.type = 'wall';
                mapMeshes.push(c);
            }
        });
        scene.add(mapObj);
    } catch(e) { console.warn("map.glb no cargado", e); }

    // BOT PROTOTYPE
    try {
        botPrototype = await loader.loadAsync('model.bot.obj');
        botPrototype.scale.setScalar(100);
        botPrototype.traverse(c => {
            if (c.isMesh) {
                c.material = wireMaterialBot;
                c.userData.type = 'bot';
            }
        });
    } catch(e) { console.warn("model.bot.obj no cargado", e); }

    // BOT LOCAL
    if (botPrototype) {
        const bot0 = botPrototype.clone();
        bot0.position.set(0, 0, 0);
        scene.add(bot0);
        players[0] = bot0;
        botMeshes.push(bot0);
        //createBotSensor(0);
    }

    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);

    connectSSE();
    animate();
}

function onKeyDown(e){
    if (e.code === 'KeyW') move.forward = true;
    if (e.code === 'KeyS') move.backward = true;
    if (e.code === 'KeyA') move.left = true;
    if (e.code === 'KeyD') move.right = true;
}

function onKeyUp(e){
    if (e.code === 'KeyW') move.forward = false;
    if (e.code === 'KeyS') move.backward = false;
    if (e.code === 'KeyA') move.left = false;
    if (e.code === 'KeyD') move.right = false;
}

function createBotSensor(id) {
    botRaycasters[id] = new THREE.Raycaster();

    const line = new THREE.Line(
        new THREE.BufferGeometry(),
        new THREE.LineBasicMaterial({ color: 0xffffff })
    );
    scene.add(line);
    forwardLines[id] = line;
}

function updatePlayerMovement(id = 0) {
    const bot = players[id];
    if (!bot) return;

    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    dir.y = 0;
    dir.normalize();

    if(id===0) { const right = new THREE.Vector3().crossVectors(dir, camera.up).normalize(); }

    if (move.forward)  bot.position.addScaledVector(dir, playerSpeed);
    if (move.backward) bot.position.addScaledVector(dir, -playerSpeed);
    if (move.left)     bot.position.addScaledVector(right, -playerSpeed);
    if (move.right)    bot.position.addScaledVector(right, playerSpeed);

    controls.target.copy(bot.position);
}

function updateAllSensors() {
    for (const id_aux in players) {
        const id = parseInt(id_aux)
        if(id == 0){
            updatePlayerMovement();
            continue;
        }else{
            updatePlayerMovement(id);
            const bot = players[id];
            const ray = botRaycasters[id];
            const line = forwardLines[id];

            const origin = bot.position.clone();
            origin.y += SENSOR_HEIGHT;

            const forward = new THREE.Vector3();
            bot.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize().multiplyScalar(-1);

            const start = origin.clone().addScaledVector(forward, FORWARD_OFFSET);
            const end = start.clone().addScaledVector(forward, SENSOR_LENGTH);

            line.geometry.setFromPoints([start, end]);

            ray.set(start, forward);
            const hits = ray.intersectObjects([...mapMeshes, ...botMeshes.filter(b => b !== bot)], true);

            let color = COLOR_FREE.clone();
            if (hits.length > 0) {
                const t = hits[0].object.userData?.type;
                if (t === 'wall'){
                    color = COLOR_WALL.clone();
                    //console.log('bot pierde vision')
                    
                    process_state(id, BOT_STATES.NO_ATTACK)
                }
                if (t === 'bot'){
                    process_state(id, BOT_STATES.ATTACK)
                    //console.log('bot pide disparar a jugador')
                    color = COLOR_BOT.clone();
                }
            }
            line.material.color.copy(color);
        }
    }
}
const SENSOR_DT = 1; // 100 ms = 10 Hz
let acc = 0;
const clock = new THREE.Clock();
function animate() {
    requestAnimationFrame(animate);

    acc += clock.getDelta();

    if(acc >= SENSOR_DT){
        updateAllSensors();
        acc = 0;
    }
    controls.update();

    renderer.render(scene, camera);
}

function onResize() {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
}

// SSE
function connectSSE() {
    const source = new EventSource('/api/connect');
    source.onmessage = e => {
        try {
            processAction(JSON.parse(e.data));
        } catch(err) {
            console.error(new Error(err))
        }
    };
}
let last_player = 0
function processAction(action) {
    if (action.type_action === 'spawn' && botPrototype && action.id_bot !== 0) {
        if(!players[action.id_bot]){
            const bot = botPrototype.clone();
            bot.position.set(action.value_action.x, action.value_action.z, -action.value_action.y);
            scene.add(bot);
            players[action.id_bot] = bot;
            process_state(action.id_bot, BOT_STATES.NO_ATTACK)
            botMeshes.push(bot);
            createBotSensor(action.id_bot);
            initPatrol(action.id_bot, action.value_action.x, action.value_action.z);
        }
    }

    if (action.type_action === 'sync') {
        console.log('Players disponibles:', Object.keys(players)); 
        if(action.id_bot == 0){
            last_player = action.value_action.r
        }
        const bot = players[action.id_bot];
        console.log(`sync bot: ${action.id_bot}`, !bot,action.value_action.x, action.value_action.z, -action.value_action.y, action.value_action.r )
        if (!bot) return;

        bot.position.set(action.value_action.x, action.value_action.z, -action.value_action.y);

        if (typeof action.value_action.r === 'number') {
            bot.rotation.y = -(action.value_action.r / 256) * Math.PI * 2;
        }



    }
    
    if (action.type_action === 'die' && action.id_bot !== 0) {
        
        const id = action.id_bot;
        console.log('boy die: ', id)
        const bot = players[id];

        if (!bot) return;

        scene.remove(bot);

        const i = botMeshes.indexOf(bot);
        if (i !== -1) botMeshes.splice(i, 1);

        if (forwardLines[id]) {
            scene.remove(forwardLines[id]);
            forwardLines[id].geometry.dispose();
            forwardLines[id].material.dispose();
            delete forwardLines[id];
        }

        delete botRaycasters[id];

        delete players[id];
        delete botPatrolData[id]; // LIMPIAR DATOS DE PATRULLAJ
    }
}
function actuar(id_bot){
    const bot = players[id_bot];
    if (!bot) return;
    
    const patrolData = botPatrolData[id_bot];
    if (!patrolData || patrolData.state !== BOT_STATES.PATROL) {
        // DANCE BANANA (tu código original)
        send_action(id_bot, move_actions.left.action_type)
        send_action(id_bot, move_actions.right.action_type)
        return;
    }
    
    const decision = decidir(id_bot);
    
    if (decision) {
        const direction = decision.direction;
        const targetRotation = Math.atan2(direction.x, direction.z);
        bot.rotation.y = targetRotation;
        send_action(id_bot, move_actions.forward.action_type);
    }
}

function decidir(id_bot) {
    const bot = players[id_bot];
    if (!bot) return null;
    
    const patrolData = botPatrolData[id_bot];
    if (!patrolData || patrolData.state !== BOT_STATES.PATROL) {
        return null;
    }
    
    const currentTime = Date.now();
    const botPosition = bot.position;
    
    if (patrolData.waiting) {
        if (currentTime - patrolData.lastWaypointTime > PATROL_CONFIG.WAIT_TIME) {
            patrolData.waiting = false;
            patrolData.currentWaypointIndex = (patrolData.currentWaypointIndex + 1) % patrolData.waypoints.length;
        } else {
            return null;
        }
    }
    
    if (patrolData.waypoints.length === 0) return null;
    
    const targetWaypoint = patrolData.waypoints[patrolData.currentWaypointIndex];
    
    const dx = targetWaypoint.x - botPosition.x;
    const dz = targetWaypoint.z - botPosition.z;
    const distance = Math.sqrt(dx * dx + dz * dz);
    
    if (distance < PATROL_CONFIG.WAYPOINT_RADIUS) {
        patrolData.waiting = true;
        patrolData.lastWaypointTime = currentTime;
        return null;
    }
    
    return {
        direction: {
            x: dx / distance,
            z: dz / distance
        },
        distance: distance
    };
}

function predict(id_bot){
    return undefined
}
async function process_state(id_bot, state){
    const last_state = state_bots[id_bot]
    state_bots[id_bot] = state
    
    switch(state_bots[id_bot]){
        case BOT_STATES.ATTACK:
            if(last_state !== BOT_STATES.ATTACK){
                console.log('attack')
                await send_action(id_bot, BOT_STATES.ATTACK)
            }
        break;
        case BOT_STATES.NO_ATTACK:
            console.log('no attack')
        break;
        default: 
        break;
    }

}
async function send_action(id_bot, action){
        const response_connection = await fetch('/api/action_bot',{
        method: 'POST',
        headers: {
            "Content-Type": "application/json"
        },
        body: JSON.stringify({
            id_bot: id_bot,
            state_bot: action 
        }),

    })
}
</script>

<div class="welcome"><span>torrenteservidor.es</span></div>


<div class="formulario">
    <div class="tituloformulario"><span>CONECTAR BOTS</span></div>
    <div class="datosformulario">
        <label>Dirección IP:<br><input type="text" id="ipv4" value="192.168.1.130"></label>
        <label>Puerto:<br><input type="number" id="puerto" value="8888"></label>
        <label>Número de bots:<br><input type="number" id="numbots" max="32" value="15"></label>
        <input id="boton" type="button" value="Conectar" onclick="btnocultar()">
    </div>
    <div class="btnocultar"><button>Mostrar / Ocultar</button></div>
</div>

<script src="index.js"></script>

<div id="ocultar" style="display: none;"></div>
</body>
</html>
