<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Torrente online bots</title>
    <link rel="stylesheet" href="styles.css">
    <style>body { margin:0 }</style>
</head>
<body>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

let camera, scene, renderer, controls;
let mapMeshes = [];
let botMeshes = [];
let players = {};
let state_bots = {
}
let status_player_bot = {}
const move_actions = {camera_right: {action_type: "camera_right"}, camera_left: {action_type: "camera_left"}, forward: {action_type: "forward_move"}}
const BOT_STATES = {
    NO_ATTACK: 'no_attack',
    PATROL: 'patrol',
    CHASE: 'chase',
    ATTACK: 'attack'
};

const PATROL_CONFIG = {
    WAYPOINT_RADIUS: 5,
    WAIT_TIME: 2000,
    PATROL_SPEED: 0.5,
    EXPLORATION_RANGE: 20
};
const botPatrolData = {};


let forwardLines = {};
let botRaycasters = {};
let botPrototype;
const wireMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });


const wireMaterialBot = new THREE.MeshBasicMaterial({ color: 0x00c8ff, wireframe: true });

const move = { forward: false, backward: false, left: false, right: false };
const playerSpeed = 0.25;

const SENSOR_HEIGHT  = 10;
const FORWARD_OFFSET = 30;
const SENSOR_LENGTH  = 400 * 2;

const COLOR_FREE = new THREE.Color(0xff8800);
const COLOR_WALL = new THREE.Color(0xff0000);
const COLOR_BOT  = new THREE.Color(0x0000ff);

init();

async function init() {

    camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 100000);
    camera.position.set(0, 120, 250);

    scene = new THREE.Scene();

    scene.add(new THREE.AmbientLight(0xffffff, 1.2));

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(devicePixelRatio);
    document.getElementById('ocultar').appendChild(renderer.domElement);

    // ORBIT CONTROLS
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.enablePan = true;
    controls.enableZoom = true;
    controls.maxPolarAngle = Math.PI * 0.49;

    window.addEventListener('resize', onResize);

    const loader = new OBJLoader().setPath('./');
    const gloader = new GLTFLoader();

    // MAPA
    try {
        const mapObj = await loader.loadAsync('map.obj');
        mapObj.position.y = -1;

        mapObj.traverse(c => {
            if (c.isMesh) {
                c.material = wireMaterial;
                c.material.side = THREE.DoubleSide;
                c.userData.type = 'wall';
                mapMeshes.push(c);
            }
        });
        scene.add(mapObj);
        // Ejecuta esto una vez al inicio
        const mapBoundingBox = new THREE.Box3();
        mapMeshes.forEach(mesh => mapBoundingBox.expandByObject(mesh));

        const mapSize = new THREE.Vector3();
        mapBoundingBox.getSize(mapSize);

        const mapMin = mapBoundingBox.min; // esquina origen

        console.log("Mapa tamaño:", mapSize.x, mapSize.z);
        console.log("Mapa origen:", mapMin.x, mapMin.z);
    } catch(e) { console.warn("map.glb no cargado", e); }

    // BOT PROTOTYPE
    try {
        botPrototype = await loader.loadAsync('model.bot.obj');
        botPrototype.scale.setScalar(100);
        botPrototype.traverse(c => {
            if (c.isMesh) {
                c.material = wireMaterialBot;
                c.userData.type = 'bot';
            }
        });
    } catch(e) { console.warn("model.bot.obj no cargado", e); }

    // BOT LOCAL
    if (botPrototype) {
        const bot0 = botPrototype.clone();
        bot0.position.set(0, 0, 0);
        bot0.traverse(c => {
            if (c.isMesh) {
                c.userData.type = 'player';
            }
        })
        scene.add(bot0);
        players[0] = bot0;
        botMeshes.push(bot0);
  
        //createBotSensor(0);
    }

    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);

    connectSSE();
    animate();
}

function onKeyDown(e){
    if (e.code === 'KeyW') move.forward = true;
    if (e.code === 'KeyS') move.backward = true;
    if (e.code === 'KeyA') move.left = true;
    if (e.code === 'KeyD') move.right = true;
}

function onKeyUp(e){
    if (e.code === 'KeyW') move.forward = false;
    if (e.code === 'KeyS') move.backward = false;
    if (e.code === 'KeyA') move.left = false;
    if (e.code === 'KeyD') move.right = false;
}

function createBotSensor(id) {
    botRaycasters[id] = new THREE.Raycaster();

    const line = new THREE.Line(
        new THREE.BufferGeometry(),
        new THREE.LineBasicMaterial({ color: 0xffffff })
    );
    scene.add(line);
    forwardLines[id] = line;
}

function updatePlayerMovement(id = 0) {
    const bot = players[id];
    if (!bot) return;

    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    dir.y = 0;
    dir.normalize();

    if(id===0) { const right = new THREE.Vector3().crossVectors(dir, camera.up).normalize(); }

    if (move.forward)  bot.position.addScaledVector(dir, playerSpeed);
    if (move.backward) bot.position.addScaledVector(dir, -playerSpeed);
    if (move.left)     bot.position.addScaledVector(right, -playerSpeed);
    if (move.right)    bot.position.addScaledVector(right, playerSpeed);

    controls.target.copy(bot.position);
}
const SOUND_SENSOR_RADIUS = 400 * 8
function updateAllSensors() {
    const player = players[0];
    for (const id_aux in players) {
        const id = parseInt(id_aux)
        if(id == 0){
            updatePlayerMovement();
            continue;
        }else{
            updatePlayerMovement(id);
            const bot = players[id];
            const ray = botRaycasters[id];
            const line = forwardLines[id];

            const origin = bot.position.clone();
            origin.y += SENSOR_HEIGHT;

            const forward = new THREE.Vector3();
            bot.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize().multiplyScalar(-1);

            const start = origin.clone().addScaledVector(forward, FORWARD_OFFSET);
            const end = start.clone().addScaledVector(forward, SENSOR_LENGTH);

            line.geometry.setFromPoints([start, end]);

            ray.set(start, forward);
            ray.far = SENSOR_LENGTH;
            const hits = ray.intersectObjects([...mapMeshes, ...botMeshes.filter(b => b !== bot)], true);

            let color = COLOR_FREE.clone();
            let wallDetected = false;
            let playerDetected = false
            let playerDetected_in_front = false
            renderMap2D()
            if (hits.length > 0) {
                const t = hits[0].object.userData?.type;
                if (t === 'wall'){
                    color = COLOR_WALL.clone();
                    wallDetected = true;

                    // Marcar celda de la pared
                    const hitPoint = hits[0].point;
                    markCell(hitPoint.x, hitPoint.z, true);
                    
                    process_state(id, BOT_STATES.NO_ATTACK);
                }
                if (t === 'bot'){
                    process_state(id, BOT_STATES.ATTACK);
                    color = COLOR_BOT.clone();
                }
                if(t === 'player'){
                    playerDetected_in_front = true
                }
            }
            const botPos = bot.position;
            const playerPos = player.position;
            const dx = playerPos.x - botPos.x;
            const dz = playerPos.z - botPos.z;

            const distSq = dx * dx + dz * dz;
            const radiusSq = SOUND_SENSOR_RADIUS * SOUND_SENSOR_RADIUS;
            if (distSq <= radiusSq) {
                playerDetected = true
                state_bots[id] = {
                    x: playerPos.x,
                    y: playerPos.y,
                    z: playerPos.z
                }
            }
            // ===== PATRULLA MINIMA =====
            /*if (!wallDetected && !state_bots[id]) {
                send_action(id, move_actions.forward.action_type);
            }*/

            if(wallDetected){
                //send_action(id, move_actions.camera_right.action_type);
            }
            if(!wallDetected){
                markCell(bot.position.x, bot.position.z, false);
            }
            if(true){
                const new_angle_bot = angleToTarget(botPos.x, botPos.z, playerPos.x, playerPos.z);
                const target = normalizeAngle(new_angle_bot + Math.PI);
                const current = normalizeAngle(-bot.rotation.y);

                let diff = current - target;

                if (diff > Math.PI) diff -= 2 * Math.PI;
                if (diff < -Math.PI) diff += 2 * Math.PI;

                // Fix oscilación en el punto opuesto (±PI)
                
               
                if (diff > 0.15) {
                    send_action(id, move_actions.camera_left.action_type);
                } else if (diff < -0.15) {
                    send_action(id, move_actions.camera_right.action_type);
                } else  {
                    console.log("✅ Bot mirando al jugador");
                    send_action(id, move_actions.forward.action_type);
                    //send_action(id, move_actions.camera_right.action_type); // sigue girando suavemente
                }
            }
            line.material.color.copy(color);
        }
    }
}
function normalizeAngle(a) {
    return ((a % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
}
function angleToTarget(botX, botZ, targetX, targetZ) {
    const dx = targetX - botX;
    const dz = targetZ - botZ;
    
    // Ajuste para que mire hacia el objetivo (eje Z positivo)
    let angle = Math.atan2(dz, dx) - Math.PI/2;
    
    return angle;
}
const SENSOR_DT = 0.2; // 100 ms = 10 Hz
let acc = 0;
const clock = new THREE.Clock();
function animate() {
    requestAnimationFrame(animate);

    acc += clock.getDelta();

    if(acc >= SENSOR_DT){
        updateAllSensors();
        acc = 0;
    }
    controls.update();

    renderer.render(scene, camera);
}

function onResize() {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
}

// SSE
function connectSSE() {
    const source = new EventSource('/api/connect');
    source.onmessage = e => {
        try {
            processAction(JSON.parse(e.data));
        } catch(err) {
            console.error(new Error(err))
        }
    };
}
let last_player = 0
function processAction(action) {
    if (action.type_action === 'spawn' && botPrototype && action.id_bot !== 0) {
        if(!players[action.id_bot]){
            const bot = botPrototype.clone();
            bot.traverse(c => {
                if (c.isMesh) {
                
                    c.userData.type = 'bot';
                }
            });
            bot.position.set(action.value_action.x, action.value_action.z, -action.value_action.y);
            scene.add(bot);
            players[action.id_bot] = bot;
            process_state(action.id_bot, BOT_STATES.NO_ATTACK)
            botMeshes.push(bot);
            createBotSensor(action.id_bot);

        }
    }
    if(action.id_bot !== 0){
        //send_action(action.id_bot, move_actions.camera_right.action_type);
    }

    if (action.type_action === 'sync') {
        //console.log('Players disponibles:', Object.keys(players)); 
        if(action.id_bot == 0){
            last_player = action.value_action.r
        }
        const bot = players[action.id_bot];
        //console.log(`sync bot: ${action.id_bot}`, !bot,action.value_action.x, action.value_action.z, -action.value_action.y, action.value_action.r )
        if (!bot) return;

        bot.position.set(action.value_action.x, action.value_action.z, -action.value_action.y);

        if (typeof action.value_action.r === 'number') {
            bot.rotation.y = -(action.value_action.r / 256) * Math.PI * 2;
        }

        

    }
    
    if (action.type_action === 'die' && action.id_bot !== 0) {
        
        const id = action.id_bot;
        console.log('boy die: ', id)
        const bot = players[id];

        if (!bot) return;

        scene.remove(bot);

        const i = botMeshes.indexOf(bot);
        if (i !== -1) botMeshes.splice(i, 1);

        if (forwardLines[id]) {
            scene.remove(forwardLines[id]);
            forwardLines[id].geometry.dispose();
            forwardLines[id].material.dispose();
            delete forwardLines[id];
        }

        delete botRaycasters[id];

        delete players[id];
        delete botPatrolData[id]; // LIMPIAR DATOS DE PATRULLAJ
    }
}
async function process_state(id_bot, state){
    const last_state = state_bots[id_bot]
    state_bots[id_bot] = state
    
    switch(state_bots[id_bot]){
        case BOT_STATES.ATTACK:
            if(last_state !== BOT_STATES.ATTACK){
                //console.log('attack')
                await send_action(id_bot, BOT_STATES.ATTACK)
            }
        break;
        case BOT_STATES.NO_ATTACK:
            //console.log('no attack')
        break;
        default: 
        break;
    }

}
async function send_action(id_bot, action){
    const response_connection = await fetch('/api/action_bot',{
        method: 'POST',
        headers: {
            "Content-Type": "application/json"
        },
        body: JSON.stringify({
            id_bot: id_bot,
            state_bot: action 
        }),

    })
}
// ---- CONFIGURACIÓN DEL MAPA ----
const MAP_CELL_SIZE = 500; // ajusta la resolución aquí

const MAP_ORIGIN_X = -59663.0;
const MAP_ORIGIN_Z = -30040.2;
const MAP_WIDTH    = 95135.7;
const MAP_HEIGHT   = 58740.5;

const GRID_COLS = Math.ceil(MAP_WIDTH  / MAP_CELL_SIZE);
const GRID_ROWS = Math.ceil(MAP_HEIGHT / MAP_CELL_SIZE);

// 0 = libre, 1 = pared, null = desconocido
const exploredMap = Array.from({ length: GRID_ROWS }, () => 
    new Array(GRID_COLS).fill(null)
);

function worldToGrid(x, z) {
    const col = Math.floor((x - MAP_ORIGIN_X) / MAP_CELL_SIZE);
    const row = Math.floor((z - MAP_ORIGIN_Z) / MAP_CELL_SIZE);
    return { col, row };
}

function markCell(worldX, worldZ, isWall) {
    const { col, row } = worldToGrid(worldX, worldZ);
    if (row >= 0 && row < GRID_ROWS && col >= 0 && col < GRID_COLS) {
        // No sobreescribir pared ya marcada con libre
        if (exploredMap[row][col] !== 1) {
            exploredMap[row][col] = isWall ? 1 : 0;
        }
    }
}
const MAP_CANVAS_SCALE = 3; // píxeles por celda

function renderMap2D() {
    let container = document.getElementById('map2d');
    if (!container) return;

    let canvas = container.querySelector('canvas');
    if (!canvas) {
        canvas = document.createElement('canvas');
        canvas.width  = GRID_COLS * MAP_CANVAS_SCALE;
        canvas.height = GRID_ROWS * MAP_CANVAS_SCALE;
        canvas.style.border = '1px solid #fff';
        container.appendChild(canvas);
    }

    const ctx = canvas.getContext('2d');

    for (let row = 0; row < GRID_ROWS; row++) {
        for (let col = 0; col < GRID_COLS; col++) {
            const val = exploredMap[row][col];
            if      (val === null) ctx.fillStyle = '#111';   // desconocido
            else if (val === 1)    ctx.fillStyle = '#e74c3c'; // pared
            else                   ctx.fillStyle = '#2ecc71'; // libre
            ctx.fillRect(col * MAP_CANVAS_SCALE, row * MAP_CANVAS_SCALE, MAP_CANVAS_SCALE, MAP_CANVAS_SCALE);
        }
    }

    // Pintar posición del bot en azul
    for(let id_player in players ){
        const player = players[id_player]
        const pos = player.position
        const { col, row } = worldToGrid(pos.x, pos.z);
        ctx.fillStyle = '#3498db';
        ctx.fillRect(col * MAP_CANVAS_SCALE - 2, row * MAP_CANVAS_SCALE - 2, MAP_CANVAS_SCALE + 4, MAP_CANVAS_SCALE + 4);
    }

}
</script>

<div class="welcome"><span>torrenteservidor.es</span></div>


<div class="formulario">
    <div class="tituloformulario"><span>CONECTAR BOTS</span></div>
    <div class="datosformulario">
        <label>Dirección IP:<br><input type="text" id="ipv4" value="192.168.1.130"></label>
        <label>Puerto:<br><input type="number" id="puerto" value="8888"></label>
        <label>Número de bots:<br><input type="number" id="numbots" max="32" value="15"></label>
        <input id="boton" type="button" value="Conectar" onclick="btnocultar()">
    </div>
    <div class="btnocultar"><button>Mostrar / Ocultar</button></div>
</div>

<script src="index.js"></script>

<div id="ocultar" style="display: none;">

    <div id="map2d" style="position:fixed; top:10px; right:10px; z-index:9999;"></div>

</div>
</body>
</html>
