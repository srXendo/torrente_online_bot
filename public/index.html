<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>THREE FPS + Bots Raycast</title>
    <style>body { margin:0; overflow:hidden; background:#000; }</style>
</head>
<body>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

let camera, scene, renderer, controls;
let mapMeshes = [];
let botMeshes = [];
let players = {};
let forwardLines = {};
let botRaycasters = {};
let botPrototype;

const wireMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
const wireMaterialBot = new THREE.MeshBasicMaterial({ color: 0x00c8ff, wireframe: true });

const move = { forward: false, backward: false, left: false, right: false };
const playerSpeed = 0.25;

const SENSOR_HEIGHT    = 80;
const FORWARD_OFFSET   = 30;
const SENSOR_LENGTH    = 400 * 8;

const COLOR_FREE = new THREE.Color(0xff8800);
const COLOR_WALL  = new THREE.Color(0xff0000);
const COLOR_BOT   = new THREE.Color(0x0000ff);

init();

async function init() {
    camera = new THREE.PerspectiveCamera(90, innerWidth / innerHeight, 0.1, 999999);
    camera.position.set(2, 5, 2.5);

    scene = new THREE.Scene();

    scene.add(new THREE.AmbientLight(0xffffff, 1.2));
    const pl = new THREE.PointLight(0xffffff, 1);
    camera.add(pl);
    scene.add(camera);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    controls = new PointerLockControls(camera, renderer.domElement);
    document.addEventListener('click', () => controls.lock());

    const loader = new OBJLoader().setPath('./');

    // Mapa
    try {
        const mapObj = await loader.loadAsync('map.obj');
        mapObj.position.y = -1;
        mapObj.traverse(child => {
            if (child.isMesh) {
                child.material = wireMaterial;
                child.material.side = THREE.DoubleSide;
                child.userData.type = 'wall';
                mapMeshes.push(child);
            }
        });
        scene.add(mapObj);
    } catch(e) { console.warn("map.obj no cargado", e); }

    // Prototipo bot
    try {
        botPrototype = await loader.loadAsync('model.bot.obj');
        botPrototype.scale.setScalar(100);
        botPrototype.traverse(c => {
            if (c.isMesh) {
                c.material = wireMaterialBot;
                c.userData.type = 'bot';
            }
        });
    } catch(e) { console.warn("model.bot.obj no cargado", e); }

    // Bot 0 (jugador local)
    if (botPrototype) {
        const bot0 = botPrototype.clone();
        bot0.position.set(0, 0, 0);
        scene.add(bot0);
        players[0] = bot0;
        botMeshes.push(bot0);
        createBotSensor(0);
    }

    window.addEventListener('keydown', onKeyDown);
    window.addEventListener('keyup', onKeyUp);
    window.addEventListener('resize', onResize);

    connectSSE();
    animate();
}

function createBotSensor(id) {
    botRaycasters[id] = new THREE.Raycaster();

    const line = new THREE.Line(
        new THREE.BufferGeometry(),
        new THREE.LineBasicMaterial({ color: 0xffffff })
    );
    line.frustumCulled = false;
    scene.add(line);
    forwardLines[id] = line;
}

function onKeyDown(e) {
    switch(e.code){
        case 'KeyW': move.forward  = true; break;
        case 'KeyS': move.backward = true; break;
        case 'KeyA': move.left     = true; break;
        case 'KeyD': move.right    = true; break;
    }
}

function onKeyUp(e) {
    switch(e.code){
        case 'KeyW': move.forward  = false; break;
        case 'KeyS': move.backward = false; break;
        case 'KeyA': move.left     = false; break;
        case 'KeyD': move.right    = false; break;
    }
}

function onResize() {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
}

function updatePlayerMovement() {
    if (!controls.isLocked || !players[0]) return;

    const dir = new THREE.Vector3();
    controls.getDirection(dir);
    dir.y = 0; dir.normalize();

    const right = new THREE.Vector3().crossVectors(camera.up, dir).normalize();

    if (move.forward)  players[0].position.addScaledVector(dir,   playerSpeed);
    if (move.backward) players[0].position.addScaledVector(dir,  -playerSpeed);
    if (move.left)     players[0].position.addScaledVector(right, -playerSpeed);
    if (move.right)    players[0].position.addScaledVector(right,  playerSpeed);

    updateCameraFollow();
}

function updateCameraFollow() {
    if (!players[0]) return;
    const p = players[0].position.clone();
    const rot = players[0].rotation.y;
    const offset = new THREE.Vector3(0, 40, 120); // ajusta si es necesario
    offset.applyAxisAngle(new THREE.Vector3(0,1,0), rot);
    camera.position.copy(p).add(offset);
    camera.lookAt(p.x, p.y + 30, p.z);
}

function updateAllSensors() {
    for (const id in players) {
        const bot = players[id];
        const ray = botRaycasters[id];
        const line = forwardLines[id];

        const origin = bot.position.clone();
        origin.y += SENSOR_HEIGHT;

        const forward = new THREE.Vector3();
        bot.getWorldDirection(forward);
        forward.y = 0;
        forward.normalize();
        forward.multiplyScalar(-1);
        const start = origin.clone().addScaledVector(forward, FORWARD_OFFSET);
        const end = start.clone().addScaledVector(forward, SENSOR_LENGTH);

        line.geometry.setFromPoints([start, end]);
        line.geometry.attributes.position.needsUpdate = true;

        ray.set(start, forward);
        const hits = ray.intersectObjects([...mapMeshes, ...botMeshes.filter(b => b !== bot)], true);

        let color = COLOR_FREE.clone();
        if (hits.length > 0) {
            const hit = hits[0];
            if (hit.distance < SENSOR_LENGTH) {
                const type = hit.object.userData?.type;
                if (type === 'wall') color = COLOR_WALL.clone();
                if (type === 'bot')  color = COLOR_BOT.clone();
            }
        }
        line.material.color.copy(color);
    }
}

function animate() {
    requestAnimationFrame(animate);
    updatePlayerMovement();
    updateAllSensors();
    renderer.render(scene, camera);
}

// SSE
function connectSSE() {
    const source = new EventSource('/api/connect');
    source.onmessage = e => {
        try {
            const action = JSON.parse(e.data);
            processAction(action);
        } catch(err) {
            console.error("SSE parse error", err);
        }
    };
    source.onerror = () => console.log("SSE error/reconnecting...");
}

function processAction(action) {
    switch(action.type_action) {
        case 'spawn':
            if (action.id_bot == 0) return;
            if (!botPrototype) return;

            const bot = botPrototype.clone();
            bot.position.set(
                action.value_action.x,
                action.value_action.z,
                -action.value_action.y
            );
            scene.add(bot);
            players[action.id_bot] = bot;
            botMeshes.push(bot);
            createBotSensor(action.id_bot);
            break;

        case 'sync':
            const bot2 = players[action.id_bot];
            if (!bot2) return;

            bot2.position.set(
                action.value_action.x,
                action.value_action.z,
                -action.value_action.y
            );

            if (typeof action.value_action.r === 'number') {
                const rot = (action.value_action.r / 256) * Math.PI * 2;
                bot2.rotation.y = -rot;  // Unificado para todos: -rot para mirar en la misma direcci√≥n
            }

            if (action.id_bot === 0) updateCameraFollow();
            break;
    }
}
</script>
</body>
</html>